---
layout: post
title: 动态库的搜索路径及多版本兼容问题的探讨
description:
keywords: 动态库
---

### 一、 动态库的搜索路径搜索的先后顺序是及修改方法：

 - 编译目标代码时指定的动态库搜索路径
	使用方法：通过gcc 的参数"-Wl,-rpath,"指定，
	当指定多个动态库搜索路径时，路径之间用冒号"："分隔
	样例：
```
example:
gcc
-Wl,-rpath,/home/test/lib,-rpath,/lib/,-rpath,/usr/lib/,-rpath,/usr/local/lib
```

- 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
	使用方法：使用export去修改环境变量，如果想全局使用
	，需要将export内容添加到/etc/profile 或者.bashrc文件中，
	前者是针对所有用户，后者是针对单个用户的。
	样例：
	```
	export LD_LIBRARY_PATH=/root/test/lib
	```
- 配置文件/etc/ld.so.conf中指定的动态库搜索路径
	使用方法：直接将库的路径添加到/etc/ld.so.conf文件中
- 默认的动态库搜索路径/lib
- 默认的动态库搜索路径/usr/lib

特别说明：除了第一种方法，通过改变gcc的编译参数来修改搜索路径之外，其余的修改搜索路径的方法，会影响到系统中所有的程序，如果你只是想针对某一个程序调整动态库的搜索路径，那么请使用第一种，也可以看成是下面动态库多版本不兼容的一个处理方法。

### 二、动态库多版本兼容问题的解决方案
Linux 使用了一套命名机制来解决这个问题，如果遵守这个机制来做，就可以避免这个问题。但是这个约定不是强制的。
如果你是一个底层库的开发者，建议你遵守这个约定。

#### linux 动态库的命名（解决生成阶段的问题）
动态库都以.so 作为文件后缀,然后再加上特别的版本号命名规则来指定兼容性，
如libABC.so.x.y.z，其中ABC是库名称，x.y.z是文件的版本号，具体含义如下(约定，非强制，可以不遵守)：
- 第一位x表示了兼容性，x不一样的so文件是不能兼容的。
- 第二位y的变化表示可能引入了新的特性（Feature), 一般情况下还是兼容的。
- 第三位z的变化一般表示仅是修正了Bug。
注意：再次强调一下，不是所有.so文件都遵循此规则，但是大部分的库都是遵守这个规则的。
这个命名的方法解决不同版本库生成时的问题，但是在运行和编译链接过程中多版本选择的问题没有解决。
#### 编译器指令-l 自动解决解决链接阶段多版本库的问题
	编译器会根据当前环境，在系统中的相关路径(由-L参数指定)查找最新版本的XXX库,这个XXX就是共享库的“链接名。
	例如同一个目录下有libXXX.1.0.1和libXXX.1.0.8这两个库，那么编译器会自动选择最高版本的libXXX.1.0.8 进行链接。
#### SO-NAME (解决运行阶段的问题)
>
Solaris和Linux等采用SO-NAME( Shortfor shared object name )的命名机制来记录共享库的依赖关系。每个共享库都有一个对应的“SO-NAME”(共享库文件名去掉次版本号和发布版本号)。

例如一个共享库名为libtest.so.3.8.2,那么它的SO-NAME就是libtest.so.3。
因为前面说了第一位版本一样的库是互相兼容的，所以程序运行时只要试图连接libtest.so.3就可以了。

生成SO-NAME 的软连接的方法是直接运行ldconfig，会自动生成活更新相关的软链接。

查看没有没有版本号的动态库的SO-NAME，运行命令：
```
readelf -d libtest.so
```

### 参考文献
[三种思路：解决动态库版本兼容](http://blog.sina.com.cn/s/blog_5cf54f0e0101cpct.html)

[动态库(.so) wiki](http://linux-wiki.cn/wiki/%E5%8A%A8%E6%80%81%E5%BA%93(.so))

